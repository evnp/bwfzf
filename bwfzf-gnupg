#!/usr/bin/env bash

bwfzf-gnupg() {
	# parse args
	local argVerbose=false
	local argDebug=false
	bwfzf-argparse "$@"

	local V="${argVerbose}"  # alias for code readability

	local originalGpgTty

	local sessionKey="${BW_SESSION}"
	local encryptedSessionKey  # encrypted bitwarden session key data
	local encodedSessionKey    # encrypted and hex-encoded session key data
	local retrievedSessionKey  # encoded session key retrieved from gpg-agent
	local decodedSessionKey    # encrypted session key retrieved from gpg-agent
	local decryptedSessionKey  # decryped session key retrieved from gpg-agent

	local pass       # randomly generated (via bitwarden) passphrase used for session key symmetric encryption
	local salt       # randomly chosen salt used during session key symmetric encryption
	local hexPass    # hex-encoded passphrase used with gpg-connect-agent preset_passphrase
	local outputMode # temp var used to store command args that invoke verbose or quiet mode for commands

	if hash gpg 2>/dev/null; then
	# use subshell so encrypt/decrypt helper functions are not exposed globally
	(

		gpgConnect() {
			local verbose="$1"
			local outputMode=""
			[[ "${verbose}" == true ]] && outputMode="-vv"
			# sed: remove extraneous/non-hex gpg output:
			# "D 0123456789abcdef OK" -> "0123456789abcdef"
			gpg-connect-agent ${outputMode} | sed 's/[^a-z0-9]//g'
		}

		gpgGetSession() {
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				getval bwfzfs
			EOF
		}

		gpgPutSession() {
			local data=$( cat )
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				putval bwfzfs ${data}
			EOF
		}

		gpgGetFilePath() {
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				getval bwfzff
			EOF
		}

		gpgPutFilePath() {
			local data=$( cat )
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				putval bwfzff ${data}
			EOF
		}

		if hash bitagent 2>/dev/null; then
			# start bitagent if it's not running already
			bitagent ~/.bwfzfs.sock 2>/dev/null
		fi

		bitAgentPutSession() {
			local data=$( cat )
			nc -U ~/.bwfzfs.sock <<-EOF
				P${data}
			EOF
		}

		bitAgentGetSession() {
			nc -U ~/.bwfzfs.sock <<-EOF
				G
			EOF
		}

		encode() {
			xxd -plain -cols 9999
		}

		decode() {
			xxd -plain -revert -cols 9999
		}

		encrypt() {
			local data=$( cat )
			local verbose="$1"
			local outputMode=""

			# generate passphrase for gpg symmetric encryption
			# https://security.stackexchange.com/questions/113309/is-a-43-character-gpg-symmetric-passphrase-as-secure-as-a-256-bit-key
			local pass=$( bw generate --length 50 )

			# use "Here Documents" shell feature to pipe session data securely from $BW_SESSION to gpg
			# this avoids leaking variable contents to pipe or process snooping
			# <<-EOF used instead of <<< for portability, per https://stackoverflow.com/a/21171367/11776945
			# --symmetric       : passphrase-only encryption, no public/private keypair
			# --yes             : (over)write output file even if it already exists
			# --passphrase-fd 3 : send passphrase over file descriptor 3 to avoid echoing it into stdin (leaking to process list)
			# --batch           : necessary for --passphrase-fd
			# --armor           : encrypt to "email-safe" format that's more resiliant to whitespace alterations
			# --output -        : force gpg to send output over stdout (piped to perm-secured file)
			# store the encrypted session key in gpg-agent
			[[ ${verbose} == true ]] && outputMode="-vv"
			local encryptedData=$(
				gpg --symmetric --compress-level 0 --yes --passphrase-fd 3 --batch --armor --output - ${outputMode} <<-EOF2 3<<-EOF3
					${data}
				EOF2
					${pass}
				EOF3
			)

			# get the 8-octet hex-encoded salt value used during encryption:
			local salt="$(
			  echo | ( gpg --list-packets 2>&1 | grep -o '[0-9A-F]\{16\}' ) <<-EOF
					${encryptedData}
				EOF
			)"

			# hex-encode the passphrase for use with gpg-connect-agent preset_passphrase
			# tr -d '\n' - need to remove trailing newline from EOF input
			local hexPass="$(
				( tr -d '\n' | hexdump -v -e '/1 "%02X"' ) <<-EOF
					${pass}
				EOF
			)"

			# preset the passphrase in gpg-agent
			# "S" prefix necessary for salt-based cacheid: https://superuser.com/a/1485486/1093343
			gpgConnect ${verbose} <<-EOF
				preset_passphrase S${salt} -1 ${hexPass}
			EOF

			cat <<-EOF
				${encryptedData}
			EOF
		}

		decrypt() {
			local verbose="$1"
			if [[ "${verbose}" == true ]]; then
				gpg --decrypt -vv --armor
			else
				gpg --decrypt 2>/dev/null
			fi
		}

		part() {
			local data="$( cat )"
			local nthPart="$1"
			local numParts="$2"
			# round up -> (numer+(denom-1))/denom
			local lenPart=$(( ( ${#data} + ( numParts - 1 ) ) / numParts ))
			local start=$(( ( lenPart * ( nthPart - 1 ) ) + 1 ))
			local end=$(( ( start + lenPart ) - 1 ))

			cut "-c${start}-${end}" <<-EOF
				${data}
			EOF
		}

		outputDebugInfo() {
			echo '┌────retrieved-file-path────┐'
			gpgGetFilePath
			echo '└───────────────────────────┘'
			echo '┌─────decoded-file-path─────┐'
			gpgGetFilePath | decode
			echo '└───────────────────────────┘'
			echo '┌────decrypted-file-path────┐'
			gpgGetFilePath | decode | decrypt
			echo '└───────────────────────────┘'

			local part=1
			local parts=2

			if hash bitagent 2>/dev/null; then
				parts=3
				echo "┌─retrieved-session-key-${part}/${parts}─┐"
				bitAgentGetSession
				echo '└───────────────────────────┘'
				echo "┌──decoded-session-key-${part}/${parts}──┐"
				bitAgentGetSession | decode
				echo '└───────────────────────────┘'
				part=$(( part + 1 ))
			fi

			echo "┌─retrieved-session-key-${part}/${parts}─┐"
			cat <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'
			echo "┌──decoded-session-key-${part}/${parts}──┐"
			decode <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'
			echo "┌─decrypted-session-key-${part}/${parts}─┐"
			( decode | decrypt ) <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'

			part=$(( part + 1 ))

			echo "┌─retrieved-session-key-${part}/${parts}─┐"
			gpgGetSession
			echo '└───────────────────────────┘'
			echo "┌──decoded-session-key-${part}/${parts}──┐"
			gpgGetSession | decode
			echo '└───────────────────────────┘'
			echo "┌─decrypted-session-key-${part}/${parts}─┐"
			gpgGetSession | decode | decrypt
			echo '└───────────────────────────┘'

			echo '┌final-decrypted-session-key┐'
			local sessionKey=""
			if hash bitagent 2>/dev/null; then
				sessionKey="${sessionKey}$(
					bitAgentGetSession | decode
				)"
			fi
			sessionKey="${sessionKey}$(
				( decode | decrypt ) <$( gpgGetFilePath | decode | decrypt )
			)$(
				gpgGetSession | decode | decrypt
			)"
			cat <<-EOF
				${sessionKey}
			EOF
			echo '└───────────────────────────┘'
		}

		# ensure no user-set GPG_TTY interferes with gpg/pinentry interaction below; restore at end of function
		originalGpgTty="${GPG_TTY}"
		export GPG_TTY=""

		sessionKey="${BW_SESSION}"

		# set BW_SESSION env var from gpg if necessary
		if [[ -z "${sessionKey}" ]]; then
			sessionKey=""

			# if bitagent is available, pull first N bytes from there (N defined below)
			if hash bitagent 2>/dev/null; then
				sessionKey="${sessionKey}$(
					bitAgentGetSession | decode
				)"
			fi

			# combine 2 session key parts:
			# ( decode | decrypt $V ) <$( gpgGetFilePath $V | decode | decrypt $V )
			#   ^ 1st half of session key, stored encrypted in temp file
			# gpgGetSession $V | decode | decrypt $V
			#   ^ 2nd half of session key, stored encrypted in gpg-agent key-value store
			sessionKey="${sessionKey}$(
				( decode | decrypt $V ) <$( gpgGetFilePath $V | decode | decrypt $V )
			)$(
				gpgGetSession $V | decode | decrypt $V
			)"

			export BW_SESSION="${sessionKey}"

			[[ ${argDebug} == true ]] && outputDebugInfo
		fi

		if hash bwfzf-autolock 2>/dev/null; then
			bwfzf-autolock "$@"
		elif hash bwfzf 2>/dev/null; then
			bwfzf "$@"
		else
			echo "Error: You're trying to use `bwfzf-gnupg` but the command `bwfzf` is not available. Add `source /path/to/bwfzf` to your .bashrc and try again."
		fi

		# if $BW_SESSION has changed, update session key stored via gpg
		if [[ ${sessionKey} != ${BW_SESSION} ]]; then
			sessionKey=${BW_SESSION}
			filePath=$( mktemp )  # perms should be 600 / -rw------- (r/w only curr user)

			( encrypt $V | encode | gpgPutFilePath $V ) <<-EOF
				${filePath}
			EOF

			# if bitagent is available, store first N bytes there
			# TODO: encrypt these bytes - bitagent has 256 max value size that is not configurable;
			#       unfortunately armored encryption results in too big of a payload and un-armored
			#       is not resiliant enough to survive storage in bitagent
			#       open a PR on bitagent making this value configurable then use "part" function to
			#       encrypt and store a full 3rd of session key (following convention for gpg-agent)
			if hash bitagent 2>/dev/null; then
				local bitAgentBytes=16
				( cut "-c-${bitAgentBytes}" | encode | bitAgentPutSession ) <<-EOF
					${sessionKey}
				EOF
				sessionKey=$(
					cut "-c$(( bitAgentBytes + 1 ))-" <<-EOF
						${sessionKey}
					EOF
				)
			fi

			( part 1 2 | encrypt $V | encode > "${filePath}" ) <<-EOF
				${sessionKey}
			EOF

			( part 2 2 | encrypt $V | encode | gpgPutSession $V ) <<-EOF
				${sessionKey}
			EOF

			[[ ${argDebug} == true ]] && outputDebugInfo
		fi

		# restore gpg/pinentry env vars
		export GPG_TTY="${originalGpgTty}"
	)
	else
		echo "Error: You're trying to use `bwfzf-gnupg` but `gpg` is not installed. Try `brew install gnupg` or consult the GnuPG docs for installation instructions on your platform: https://www.gnupg.org/documentation"
	fi
}
