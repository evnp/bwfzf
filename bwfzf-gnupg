#!/usr/bin/env bash

# TODO: add verbose mode which causes gpg commands to provide verbose output
# TODO: store half of session in randomly-named temp file (created via mktemp)

bwfzf-gnupg() {
	# parse args
	local argVerbose=false
	local argDebug=false
	bwfzf-argparse "$@"

	local V="${argVerbose}"  # alias for code readability

	local originalGpgTty

	local sessionKey="${BW_SESSION}"
	local encryptedSessionKey  # encrypted bitwarden session key data
	local encodedSessionKey    # encrypted and hex-encoded session key data
	local retrievedSessionKey  # encoded session key retrieved from gpg-agent
	local decodedSessionKey    # encrypted session key retrieved from gpg-agent
	local decryptedSessionKey  # decryped session key retrieved from gpg-agent

	local pass       # randomly generated (via bitwarden) passphrase used for session key symmetric encryption
	local salt       # randomly chosen salt used during session key symmetric encryption
	local hexPass    # hex-encoded passphrase used with gpg-connect-agent preset_passphrase
	local outputMode # temp var used to store command args that invoke verbose or quiet mode for commands

	if hash gpg 2>/dev/null; then
	# use subshell so encrypt/decrypt helper functions are not exposed globally
	(

		gpgConnect() {
			local verbose="$1"
			local outputMode=""
			[[ "${verbose}" == true ]] && outputMode="-vv"
			# sed: remove extraneous/non-hex gpg output:
			# "D 0123456789ABCDEF OK" -> "0123456789ABCDEF"
			gpg-connect-agent ${outputMode} | sed 's/[^a-z0-9]//g'
		}

		gpgGetSession() {
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				getval bwfzfs
			EOF
		}

		gpgPutSession() {
			local data=$(cat)
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				putval bwfzfs ${data}
			EOF
		}

		gpgGetFilePath() {
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				getval bwfzff
			EOF
		}

		gpgPutFilePath() {
			local data=$(cat)
			local verbose="$1"
			gpgConnect "${verbose}" <<-EOF
				putval bwfzff ${data}
			EOF
		}

		encode() {
			xxd -plain -cols 9999
		}

		decode() {
			xxd -plain -revert -cols 9999
		}

		encrypt() {
			local data=$(cat)
			local verbose="$1"
			local outputMode=""

			# generate passphrase for gpg symmetric encryption
			# https://security.stackexchange.com/questions/113309/is-a-43-character-gpg-symmetric-passphrase-as-secure-as-a-256-bit-key
			local pass=$(bw generate --length 50)

			# use "Here Documents" shell feature to pipe session data securely from $BW_SESSION to gpg
			# this avoids leaking variable contents to pipe or process snooping
			# <<-EOF used instead of <<< for portability, per https://stackoverflow.com/a/21171367/11776945
			# --symmetric       : passphrase-only encryption, no public/private keypair
			# --yes             : (over)write output file even if it already exists
			# --passphrase-fd 3 : send passphrase over file descriptor 3 to avoid echoing it into stdin (leaking to process list)
			# --batch           : necessary for --passphrase-fd
			# --armor           : encrypt to "email-safe" format that's more resiliant to whitespace alterations
			# --output -        : force gpg to send output over stdout (piped to perm-secured file)
			# store the encrypted session key in gpg-agent
			[[ ${verbose} == true ]] && outputMode="-vv"
			local encryptedData=$(
				gpg --symmetric --compress-level 0 --yes --passphrase-fd 3 --batch --armor --output - ${outputMode} <<-EOF2 3<<-EOF3
					${data}
				EOF2
					${pass}
				EOF3
			)

			# get the 8-octet hex-encoded salt value used during encryption:
			local salt="$((
				echo | gpg --list-packets 2>&1 <<-EOF
					${encryptedData}
				EOF
			) | grep -o '[0-9A-F]\{16\}')"

			# hex-encode the passphrase for use with gpg-connect-agent preset_passphrase
			# tr -d '\n' - need to remove trailing newline from EOF input
			local hexPass="$(
				(tr -d '\n' | hexdump -v -e '/1 "%02X"') <<-EOF
					${pass}
				EOF
			)"

			# preset the passphrase in gpg-agent
			# "S" prefix necessary for salt-based cacheid: https://superuser.com/a/1485486/1093343
			gpgConnect ${verbose} <<-EOF
				preset_passphrase S${salt} -1 ${hexPass}
			EOF

			cat <<-EOF
				${encryptedData}
			EOF
		}

		decrypt() {
			local verbose="$1"
			if [[ "${verbose}" == true ]]; then
				gpg --decrypt -vv --armor
			else
				gpg --decrypt 2>/dev/null
			fi
		}

		section() {
			local data="$(cat)"
			local nthSection="$1"
			local numSections="$2"
			# round up -> (numer+(denom-1))/denom
			local lenSection=$(( ( ${#data} + ( numSections - 1 ) ) / numSections ))
			local start=$(( ( lenSection * ( nthSection - 1 ) ) + 1 ))
			local end=$(( ( start + lenSection ) - 1 ))

			cut "-c${start}-${end}" <<-EOF
				${data}
			EOF
		}

		outputDebugInfo() {
			echo '┌────retrieved-file-path────┐'
			gpgGetFilePath
			echo '└───────────────────────────┘'
			echo '┌─────decoded-file-path─────┐'
			gpgGetFilePath | decode
			echo '└───────────────────────────┘'
			echo '┌────decrypted-file-path────┐'
			gpgGetFilePath | decode | decrypt
			echo '└───────────────────────────┘'

			echo '┌─retrieved-session-key-1/2─┐'
			cat <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'
			echo '┌──decoded-session-key-1/2──┐'
			decode <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'
			echo '┌─decrypted-session-key-1/2─┐'
			( decode | decrypt ) <$( gpgGetFilePath | decode | decrypt )
			echo '└───────────────────────────┘'

			echo '┌─retrieved-session-key-2/2─┐'
			gpgGetSession
			echo '└───────────────────────────┘'
			echo '┌──decoded-session-key-2/2──┐'
			gpgGetSession | decode
			echo '└───────────────────────────┘'
			echo '┌─decrypted-session-key-2/2─┐'
			gpgGetSession | decode | decrypt
			echo '└───────────────────────────┘'

			echo '┌final-decrypted-session-key┐'
			cat <<-EOF
				$(
					( decode | decrypt ) <$( gpgGetFilePath | decode | decrypt )
				)$(
					gpgGetSession | decode | decrypt
				)
			EOF
			echo '└───────────────────────────┘'
		}

		# ensure no user-set GPG_TTY interferes with gpg/pinentry interaction below; restore at end of function
		originalGpgTty="${GPG_TTY}"
		export GPG_TTY=""

		sessionKey="${BW_SESSION}"

		# set BW_SESSION env var from gpg if necessary
		if [[ -z "${sessionKey}" ]]; then

			# combine 2 session key parts:
			# ( decode | decrypt $V ) <$( gpgGetFilePath $V | decode | decrypt $V )
			#   ^ 1st half of session key, stored encrypted in temp file
			# gpgGetSession $V | decode | decrypt $V
			#   ^ 2nd half of session key, stored encrypted in gpg-agent key-value store
			sessionKey="$(
				( decode | decrypt $V ) <$( gpgGetFilePath $V | decode | decrypt $V )
			)$(
				gpgGetSession $V | decode | decrypt $V
			)"

			export BW_SESSION="${sessionKey}"

			[[ ${argDebug} == true ]] && outputDebugInfo
		fi

		if hash bwfzf-autolock 2>/dev/null; then
			bwfzf-autolock "$@"
		elif hash bwfzf 2>/dev/null; then
			bwfzf "$@"
		else
			echo "Error: You're trying to use `bwfzf-gnupg` but the command `bwfzf` is not available. Add `source /path/to/bwfzf` to your .bashrc and try again."
		fi

		# if $BW_SESSION has changed, update session key stored via gpg
		if [[ ${sessionKey} != ${BW_SESSION} ]]; then
			sessionKey=${BW_SESSION}
			filePath=$( mktemp )  # perms should be 600 / -rw------- (r/w only curr user)

			( encrypt $V | encode | gpgPutFilePath $V ) <<-EOF
				${filePath}
			EOF

			( section 1 2 | encrypt $V | encode > "${filePath}" ) <<-EOF
				${sessionKey}
			EOF

			( section 2 2 | encrypt $V | encode | gpgPutSession $V ) <<-EOF
				${sessionKey}
			EOF

			[[ ${argDebug} == true ]] && outputDebugInfo
		fi

		# restore gpg/pinentry env vars
		export GPG_TTY="${originalGpgTty}"
	)
	else
		echo "Error: You're trying to use `bwfzf-gnupg` but `gpg` is not installed. Try `brew install gnupg` or consult the GnuPG docs for installation instructions on your platform: https://www.gnupg.org/documentation"
	fi
}
