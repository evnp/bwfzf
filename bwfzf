#!/usr/bin/env bash

bwfzf-argparse() {
	local arg
	local args=( "$@" )
	local argIdx=0

	# parse any options
	while true; do
		arg="${args[argIdx]-}"
		(( argIdx++ )) || true

		case "${arg}" in
			"action:get") argAction="get" ; continue ;;
			"action:put") argAction="put" ; continue ;;
			"-q")         argQuit=true    ; continue ;;
			"-v")         argVerbose=true ; continue ;;
			"-d")         argDebug=true   ; continue ;;
			"--quit")     argQuit=true    ; continue ;;
			"--verbose")  argVerbose=true ; continue ;;
			"--debug")    argDebug=true   ; continue ;;
			"") break ;;
		esac

		# TODO handle option flag combinations, e.g. -qvd

		echo "Error: Invalid invocation: '${arg}' is not a valid argument" >&2
		return 1
	done
}

# Security measures:
# - set BW_SESSION env var in subshells only; no exposure outside of subshells
# - Here Documents (<<-EOF) used instead of echoing data over stdin throughout
#   (avoids leaking passwords to pipe or process snooping)
# - <<-EOF syntax favored over <<< for portability,
#   per https://stackoverflow.com/a/21171367/11776945

bwfzf() (  # use subshell so helper functions are not exposed globally

	editJson() {
		# create tmp file with .json extension so editors will handle it appropriately
		local tempfile="$(mktemp -u).json"
		install -m 600 /dev/null "${tempfile}"
		cat > "${tempfile}"  # read from stdin
		# courtesy of https://github.com/juliangruber/vipe/blob/master/vipe.sh#L52
		${EDITOR:-vim} "${tempfile}" < /dev/tty > /dev/tty || exit $?
		cat "${tempfile}"  # pipe through stdout
		rm "${tempfile}"
	}

	local GREEN='\033[0;32m'
	local NC='\033[0m' # No Color
	local CHECKMARK="${GREEN}✓${NC}"

	# parse optional args
	local argQuit=false
	local argVerbose=false
	local argDebug=false
	bwfzf-argparse "$@"

	if [[ "${argVerbose}" == false ]]; then
		clear
	fi

	local sessionKey

	# attempt to retrieve session key from persistence
	if [[ -z "${sessionKey}" ]]; then
		if hash bwfzf-session-persistence 2>/dev/null; then
			sessionKey=$( bwfzf-session-persistence action:get "$@" )
		fi
	fi

	local bwItemFormat='.[] | "\(.name) · \(.login.username) \(.id)"'

	# ensure output of `bw list items` (which contains passwords) is sent
	# directly through jq so that passwords can be stripped out immediately
	# and not risk exposure later in the script
	local bwItems="$(
		export BW_SESSION="${sessionKey}" ;  # set in subshell; avoid external exposure
		bw list items | jq -r "${bwItemFormat}" 2>/dev/null
	)"

	# if login or unlock required, update session env var then re-fetch items
	if [[ -z "${bwItems}" ]]; then
		sessionKey="$( bw unlock --raw )"

		if [[ "${sessionKey}" == *"not logged in"* ]]; then
			sessionKey="$( bw login --raw )"
		fi

		# session key has changed; persist the new value
		if hash bwfzf-session-persistence 2>/dev/null; then
			if [[ ${argVerbose} == true ]]; then
				bwfzf-session-persistence action:put "$@" <<-EOF
					${sessionKey}
				EOF
			else
				(
					nohup $(  # execute in background...
						bwfzf-session-persistence action:put "$@" <<-EOF
							${sessionKey}
						EOF
					) &
				) &>/dev/null  # suppress nohup output
			fi
		fi

		# ensure output of `bw list items` (which contains passwords) is sent
		# directly through jq so that passwords can be stripped out immediately
		# and not risk exposure later in the script
		local bwItems="$(
			export BW_SESSION="${sessionKey}" ;  # set in subshell; avoid external exposure
			bw list items | jq -r "${bwItemFormat}" 2>/dev/null
		)"

		if [[ -z "${bwItems}" ]]; then
			bwfzf  # retry
			return
		fi
	fi

	(  # now that we have session key, sync local bitwarden vault in background
		export BW_SESSION="${sessionKey}" ;
		nohup bw sync &
	) &>/dev/null  # suppress nohup output

	# invoke fzf on items list
	local bwItem="$(
		fzf-tmux --nth 1..-2 --with-nth 1..-2 <<-EOF
			${bwItems}
		EOF
	)"

	# get last field (id) from "name username id" row
	local bwItemId="$(
		awk '{print $NF}' <<-EOF
			${bwItem}
		EOF
	)"

	echo	# formatting

	local keyPressed
	local lastAction
	local nextField

	# perform an action (e.g. copy password to clipboard) then ask the user
	# whether to perform another action or exit
	while true; do
		# 1-9 key - copy username or password in N seconds
		if [[ "${keyPressed}" =~ ^[0-9]+$ ]]; then
			lastAction="Copying ${nextField} in ${keyPressed} seconds..."

			if [[ "${nextField}" == "username" ]]; then
				(
					(
						( sleep "${keyPressed}" ; $(
							export BW_SESSION="${sessionKey}" ;
							bw get username "${bwItemId}" | secure-pbcopy
						) ; echo -e "Username copied ${CHECKMARK}" >&3 ) & disown
					) 1>/dev/null  # suppress disown stdout
				) 3>&1  # redirect file-descriptor 3 through stdout for "copied" message
				nextField="password"
			else
				(
					(
						( sleep "${keyPressed}" ; $(
							export BW_SESSION="${sessionKey}" ;
							bw get password "${bwItemId}" | secure-pbcopy
						) ; echo -e "Password copied ${CHECKMARK}" >&3 ) & disown
					) 1>/dev/null  # suppress disown stdout
				) 3>&1  # redirect file-descriptor 3 through stdout for "copied" message
				nextField="username"
			fi

		# o key - open uri in browser
		elif [[ "${keyPressed}" == "o" ]]; then
			lastAction="URI opened ${CHECKMARK}"
			open -n "$( export BW_SESSION="${sessionKey}" ; bw get uri "${bwItemId}" )"

		# p key - print full entry
		elif [[ "${keyPressed}" == "p" ]]; then
			# print the full entry with password fields redacted
			echo "$(
				export BW_SESSION="${sessionKey}" ;
				bw get item "${bwItemId}" | jq 'del(.login.password)'
			)" | jq .
			echo

		# e key - edit full entry
		elif [[ "${keyPressed}" == "e" ]]; then
			# edit the entry with password fields redacted
			# full entry (password unredacted) needs to be merged in before sending to `bw edit`,
			# otherwise password field will be deleted
			(
				export BW_SESSION="${sessionKey}" ;
				jq -s '.[0] * .[1]' <(
					bw get item "${bwItemId}"
				) <(
					bw get item "${bwItemId}" | jq 'del(.login.password)'| editJson
				) | bw encode | bw edit item "${bwItemId}"
			) >/dev/null  # suppress bw edit output (contains password)
			echo -e "Entry saved ${CHECKMARK}"
			echo

		# l key - lock vault & exit
		elif [[ "${keyPressed}" == "l" ]]; then
			(
				( sleep "${BWFZF_CLIPBOARD_EXPIRE_SEC:-10}" ;
					echo "" | secure-pbcopy  # clear clipboard in N seconds (default 10)
				) & disown
			) 1>/dev/null  # suppress disown stdout
			bw lock
			break

		# enter key - copy password, username, uri, etc.
		elif [[ -z "${keyPressed}" ]]; then
			if [[ "${nextField}" == "username" ]]; then
				$(
					export BW_SESSION="${sessionKey}" ;
					bw get username "${bwItemId}" | secure-pbcopy
				)
				lastAction="Username copied ${CHECKMARK}"
				nextField="password"
			else
				$(
					export BW_SESSION="${sessionKey}" ;
					bw get password "${bwItemId}" | secure-pbcopy
				)
				lastAction="Password copied ${CHECKMARK}"
				nextField="username"
			fi

		# any other key - exit
		else
			(
				( sleep "${BWFZF_CLIPBOARD_EXPIRE_SEC:-10}" ;
					echo "" | secure-pbcopy  # clear clipboard in N seconds (default 10)
				) & disown
			) 1>/dev/null  # suppress disown stdout
			break
		fi

printf "${lastAction}"
		read -rsn1 -p "

  enter -> copy ${nextField}
  0 - 9 -> copy ${nextField} in N seconds
  o key -> open in browser
  p key -> print full entry (password redacted)
  e key -> edit entry (password redacted)
  x key -> change entry password
  l key -> lock vault & exit
  other -> exit

"		keyPressed
	done

	if [[ "${argQuit}" == true ]]; then
		exit 0  # close terminal window
	fi

)  # end subshell
